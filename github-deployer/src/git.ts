/**
 * Git command helpers for the GitHub Pages Publisher Plugin
 *
 * Executes git commands via moss-api's executeBinary.
 */

import { executeBinary } from "@symbiosis-lab/moss-api";
import { log } from "./utils";

/**
 * Run a git command and return the output
 */
async function runGit(args: string[], cwd: string): Promise<string> {
  await log("log", `   git ${args.join(" ")}`);

  const result = await executeBinary({
    binaryPath: "git",
    args,
    workingDir: cwd,
    timeoutMs: 60000,
  });

  if (!result.success) {
    const error = result.stderr || `Git command failed with exit code ${result.exitCode}`;
    throw new Error(error);
  }

  return result.stdout.trim();
}

/**
 * Check if a path exists using git status (works without direct filesystem access)
 */
export async function checkPathExists(projectPath: string, relativePath: string): Promise<boolean> {
  try {
    // Try to get status of the path - if it doesn't exist, git will error
    await runGit(["ls-files", "--error-unmatch", relativePath], projectPath);
    return true;
  } catch {
    // Path not tracked, check if it exists on disk via a different approach
    // For .git directory, we can check by running a git command that requires it
    if (relativePath === ".git") {
      try {
        await runGit(["rev-parse", "--git-dir"], projectPath);
        return true;
      } catch {
        return false;
      }
    }
    return false;
  }
}

/**
 * Get the origin remote URL
 */
export async function getRemoteUrl(projectPath: string): Promise<string> {
  return runGit(["remote", "get-url", "origin"], projectPath);
}

/**
 * Detect the default branch (main or master)
 */
export async function detectBranch(projectPath: string): Promise<string> {
  try {
    // Try to get current branch first
    const branch = await runGit(["branch", "--show-current"], projectPath);
    if (branch) {
      return branch;
    }
  } catch {
    // Ignore - will try fallbacks
  }

  // Fallback: check if main exists
  try {
    await runGit(["rev-parse", "--verify", "main"], projectPath);
    return "main";
  } catch {
    // Ignore - will try master
  }

  // Fallback: check if master exists
  try {
    await runGit(["rev-parse", "--verify", "master"], projectPath);
    return "master";
  } catch {
    // Default to main
    return "main";
  }
}

/**
 * Check if directory is a git repository
 */
export async function isGitRepository(projectPath: string): Promise<boolean> {
  try {
    await runGit(["rev-parse", "--git-dir"], projectPath);
    return true;
  } catch {
    return false;
  }
}

/**
 * Check if remote exists and get its URL
 */
export async function hasGitRemote(projectPath: string): Promise<boolean> {
  try {
    await getRemoteUrl(projectPath);
    return true;
  } catch {
    return false;
  }
}

/**
 * Stage files for commit
 */
export async function stageFiles(projectPath: string, files: string[]): Promise<void> {
  await runGit(["add", ...files], projectPath);
}

/**
 * Create a commit with a message
 */
export async function commit(projectPath: string, message: string): Promise<string> {
  await runGit(["commit", "-m", message], projectPath);
  return runGit(["rev-parse", "HEAD"], projectPath);
}

/**
 * Push to remote
 */
export async function push(projectPath: string): Promise<void> {
  await runGit(["push"], projectPath);
}

/**
 * Stage, commit, and push workflow files
 */
export async function commitAndPushWorkflow(projectPath: string): Promise<string> {
  await log("log", "   Staging workflow and gitignore...");
  await stageFiles(projectPath, [".github/workflows/moss-deploy.yml", ".gitignore"]);

  await log("log", "   Creating commit...");
  const sha = await commit(projectPath, "Add GitHub Pages deployment workflow\n\nGenerated by Moss");

  await log("log", "   Pushing to remote...");
  await push(projectPath);

  return sha;
}

/**
 * Extract GitHub owner and repo from remote URL
 */
export function parseGitHubUrl(remoteUrl: string): { owner: string; repo: string } | null {
  // Parse HTTPS URLs: https://github.com/user/repo.git
  const httpsMatch = remoteUrl.match(/^https:\/\/github\.com\/([^/]+)\/([^/.]+)(\.git)?$/);
  if (httpsMatch) {
    return { owner: httpsMatch[1], repo: httpsMatch[2] };
  }

  // Parse SSH URLs: git@github.com:user/repo.git
  const sshMatch = remoteUrl.match(/^git@github\.com:([^/]+)\/([^/.]+)(\.git)?$/);
  if (sshMatch) {
    return { owner: sshMatch[1], repo: sshMatch[2] };
  }

  return null;
}

/**
 * Extract GitHub Pages URL from remote URL
 */
export function extractGitHubPagesUrl(remoteUrl: string): string {
  const parsed = parseGitHubUrl(remoteUrl);
  if (!parsed) {
    throw new Error("Could not parse GitHub URL from remote");
  }
  return `https://${parsed.owner}.github.io/${parsed.repo}`;
}
