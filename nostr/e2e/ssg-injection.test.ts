/**
 * E2E Tests for SSG-aware Widget Injection
 *
 * These tests verify that the Nostr comment widget correctly injects
 * into HTML generated by different Static Site Generators (SSGs).
 *
 * Test categories:
 * 1. SSG Detection - Verify correct SSG identification from HTML
 * 2. Insertion Point - Verify widget is inserted at the correct location
 * 3. Edge Cases - Verify handling of unusual HTML structures
 * 4. XSS Prevention - Verify malicious content is escaped
 *
 * Requirements:
 * - Run with: npm run test:e2e
 */

import { describe, it, expect, beforeAll } from "vitest";
import * as fs from "fs";
import * as path from "path";
import {
  findInsertionPoint,
  injectWidget,
  detectSSG,
  type SSGType,
} from "../src/widget/inject";

// Path to test fixtures
const FIXTURES_DIR = path.resolve(__dirname, "fixtures");

/**
 * Load fixture HTML file
 */
function loadFixture(ssg: string, filename: string): string {
  const filePath = path.join(FIXTURES_DIR, ssg, filename);
  if (!fs.existsSync(filePath)) {
    throw new Error(`Fixture not found: ${filePath}`);
  }
  return fs.readFileSync(filePath, "utf-8");
}

/**
 * Create test widget HTML
 */
function createTestWidget(interactionCount: number = 1): string {
  return `<section id="moss-comments" class="social-interactions">
  <script type="application/json" id="moss-comments-data">
    {"interactions": ${JSON.stringify(Array(interactionCount).fill({ id: "test", content: "Test comment" }))}}
  </script>
  <noscript>
    <div class="interactions-static">
      <h3>Comments (${interactionCount})</h3>
      <p>Test comment</p>
    </div>
  </noscript>
</section>`;
}

/**
 * Create test loader script
 */
function createTestLoader(): string {
  return `
<script>
(function() {
  if (!document.getElementById('moss-comments')) return;
  var s = document.createElement('script');
  s.src = '/js/moss-comments.js';
  s.async = true;
  document.body.appendChild(s);
})();
</script>`;
}

describe("SSG Detection", () => {
  it("detects Hugo from generator meta tag", () => {
    const html = loadFixture("hugo", "post.html");
    expect(detectSSG(html)).toBe("hugo");
  });

  it("detects Hexo from generator meta tag", () => {
    const html = loadFixture("hexo", "post.html");
    expect(detectSSG(html)).toBe("hexo");
  });

  it("detects Astro from data-astro attributes", () => {
    const html = loadFixture("astro", "post.html");
    expect(detectSSG(html)).toBe("astro");
  });

  it("detects Jekyll from generator meta tag", () => {
    const html = loadFixture("jekyll", "post.html");
    expect(detectSSG(html)).toBe("jekyll");
  });

  it("detects Zola from generator meta tag", () => {
    const html = loadFixture("zola", "post.html");
    expect(detectSSG(html)).toBe("zola");
  });

  it("detects Eleventy from generator meta tag", () => {
    const html = loadFixture("eleventy", "post.html");
    expect(detectSSG(html)).toBe("11ty");
  });

  it("returns unknown for pages without SSG markers", () => {
    const html = loadFixture("edge-cases", "minimal.html");
    expect(detectSSG(html)).toBe("unknown");
  });
});

describe("Insertion Point Finding", () => {
  describe("Hugo", () => {
    it("finds </article> tag as insertion point", () => {
      const html = loadFixture("hugo", "post.html");
      const insertionPoint = findInsertionPoint(html);

      // Should be before </article>
      expect(html.slice(insertionPoint, insertionPoint + 10)).toBe("</article>");
    });
  });

  describe("Hexo", () => {
    it("finds </article> tag in Hexo structure", () => {
      const html = loadFixture("hexo", "post.html");
      const insertionPoint = findInsertionPoint(html);

      expect(html.slice(insertionPoint, insertionPoint + 10)).toBe("</article>");
    });
  });

  describe("Astro", () => {
    it("finds </article> tag in Astro structure", () => {
      const html = loadFixture("astro", "post.html");
      const insertionPoint = findInsertionPoint(html);

      expect(html.slice(insertionPoint, insertionPoint + 10)).toBe("</article>");
    });
  });

  describe("Jekyll", () => {
    it("finds </article> tag in Jekyll structure", () => {
      const html = loadFixture("jekyll", "post.html");
      const insertionPoint = findInsertionPoint(html);

      expect(html.slice(insertionPoint, insertionPoint + 10)).toBe("</article>");
    });
  });

  describe("Zola", () => {
    it("finds </article> tag in Zola structure", () => {
      const html = loadFixture("zola", "post.html");
      const insertionPoint = findInsertionPoint(html);

      expect(html.slice(insertionPoint, insertionPoint + 10)).toBe("</article>");
    });
  });

  describe("Eleventy", () => {
    it("finds </article> tag in Eleventy structure", () => {
      const html = loadFixture("eleventy", "post.html");
      const insertionPoint = findInsertionPoint(html);

      expect(html.slice(insertionPoint, insertionPoint + 10)).toBe("</article>");
    });
  });
});

describe("Edge Cases", () => {
  describe("No Article Tag", () => {
    it("falls back to </main> when no article tag exists", () => {
      const html = loadFixture("edge-cases", "no-article.html");
      const insertionPoint = findInsertionPoint(html);

      // Should fall back to </main>
      expect(html.slice(insertionPoint, insertionPoint + 7)).toBe("</main>");
    });

    it("injects widget before </main>", () => {
      const html = loadFixture("edge-cases", "no-article.html");
      const widget = createTestWidget();
      const loader = createTestLoader();

      const result = injectWidget(html, widget, loader);

      expect(result).toContain('id="moss-comments"');
      expect(result).toContain("moss-comments.js");
      // Widget should be before </main>
      const widgetIndex = result.indexOf("moss-comments");
      const mainEndIndex = result.indexOf("</main>");
      expect(widgetIndex).toBeLessThan(mainEndIndex);
    });
  });

  describe("Nested Articles", () => {
    it("finds the last </article> tag", () => {
      const html = loadFixture("edge-cases", "nested-articles.html");
      const insertionPoint = findInsertionPoint(html);

      // lastIndexOf should find the outermost </article>
      const lastArticleIndex = html.lastIndexOf("</article>");
      expect(insertionPoint).toBe(lastArticleIndex);
    });
  });

  describe("Minimal HTML", () => {
    it("handles minimal HTML structure", () => {
      const html = loadFixture("edge-cases", "minimal.html");
      const widget = createTestWidget();
      const loader = createTestLoader();

      const result = injectWidget(html, widget, loader);

      expect(result).toContain('id="moss-comments"');
      expect(result).toContain("</body>");
    });
  });

  describe("Multiple Main Tags", () => {
    it("finds </article> even with multiple main tags", () => {
      const html = loadFixture("edge-cases", "multiple-main.html");
      const insertionPoint = findInsertionPoint(html);

      // Should find </article>, not any of the multiple </main> tags
      expect(html.slice(insertionPoint, insertionPoint + 10)).toBe("</article>");
    });
  });

  describe("Unicode Content", () => {
    it("handles Unicode content correctly", () => {
      const html = loadFixture("edge-cases", "unicode-content.html");
      const widget = createTestWidget();
      const loader = createTestLoader();

      const result = injectWidget(html, widget, loader);

      // Original Unicode content should be preserved
      expect(result).toContain("ä¸­æ–‡å†…å®¹æµ‹è¯•");
      expect(result).toContain("ã“ã‚“ã«ã¡ã¯");
      expect(result).toContain("ðŸŒ");

      // Widget should be injected
      expect(result).toContain('id="moss-comments"');
    });
  });
});

describe("Widget Injection", () => {
  const ssgTypes: SSGType[] = ["hugo", "hexo", "astro", "jekyll", "zola", "11ty"];

  ssgTypes.forEach((ssg) => {
    // Map SSG type to fixture folder name
    const fixtureFolder = ssg === "11ty" ? "eleventy" : ssg;

    describe(`${ssg.toUpperCase()}`, () => {
      it("injects widget with correct structure", () => {
        const html = loadFixture(fixtureFolder, "post.html");
        const widget = createTestWidget(3);
        const loader = createTestLoader();

        const result = injectWidget(html, widget, loader);

        // Widget section should exist
        expect(result).toContain('id="moss-comments"');
        expect(result).toContain('id="moss-comments-data"');

        // Noscript fallback should exist
        expect(result).toContain("<noscript>");
        expect(result).toContain("Comments (3)");

        // Loader script should exist
        expect(result).toContain("moss-comments.js");

        // Original content should be preserved
        expect(result).toContain("Test Post");
      });

      it("adds data-preserve-scroll attribute", () => {
        const html = loadFixture(fixtureFolder, "post.html");
        const widget = createTestWidget();
        const loader = createTestLoader();

        const result = injectWidget(html, widget, loader);

        expect(result).toContain('data-preserve-scroll="true"');
      });

      it("places loader script before </body>", () => {
        const html = loadFixture(fixtureFolder, "post.html");
        const widget = createTestWidget();
        const loader = createTestLoader();

        const result = injectWidget(html, widget, loader);

        const loaderIndex = result.indexOf("moss-comments.js");
        const bodyEndIndex = result.lastIndexOf("</body>");

        expect(loaderIndex).toBeLessThan(bodyEndIndex);
        expect(loaderIndex).toBeGreaterThan(0);
      });
    });
  });
});

describe("XSS Prevention", () => {
  it("should not execute script tags in JSON data", () => {
    const html = loadFixture("edge-cases", "xss-in-content.html");

    // Create widget with malicious content
    const maliciousInteraction = {
      id: "xss-test",
      content: '<script>alert("xss")</script>',
      author: { name: '<img src=x onerror="alert(1)">' },
    };

    const widgetHtml = `<section id="moss-comments">
  <script type="application/json" id="moss-comments-data">
    ${JSON.stringify({ interactions: [maliciousInteraction] })}
  </script>
  <noscript>
    <div class="interactions-static">
      <p>&lt;script&gt;alert("xss")&lt;/script&gt;</p>
    </div>
  </noscript>
</section>`;

    const loader = createTestLoader();
    const result = injectWidget(html, widgetHtml, loader);

    // JSON.stringify should escape the script tags in the JSON data
    // The noscript fallback should have escaped HTML
    expect(result).toContain("&lt;script&gt;");
    expect(result).toContain("&lt;/script&gt;");

    // The raw script tag should not appear in the noscript section
    const noscriptSection = result.match(/<noscript>[\s\S]*?<\/noscript>/)?.[0] ?? "";
    expect(noscriptSection).not.toContain('<script>alert');
    expect(noscriptSection).not.toContain('onerror=');
  });
});

describe("Additional Edge Cases", () => {
  describe("Self-closing Tags", () => {
    it("handles HTML with self-closing tags", () => {
      const html = loadFixture("edge-cases", "self-closing-tags.html");
      const widget = createTestWidget();
      const loader = createTestLoader();

      const result = injectWidget(html, widget, loader);

      expect(result).toContain('id="moss-comments"');
      // Should preserve self-closing tags
      expect(result).toContain('/>');
    });
  });

  describe("HTML Comments", () => {
    it("finds real </article> not one in HTML comment", () => {
      const html = loadFixture("edge-cases", "comments-in-html.html");
      const insertionPoint = findInsertionPoint(html);

      // The real </article> is after the main content, not in the comment
      const textAfter = html.slice(insertionPoint, insertionPoint + 20);
      expect(textAfter).toContain("</article>");

      // Verify injection works
      const widget = createTestWidget();
      const loader = createTestLoader();
      const result = injectWidget(html, widget, loader);
      expect(result).toContain('id="moss-comments"');
    });
  });

  describe("Script with HTML Content", () => {
    it("finds real </article> not one inside script", () => {
      const html = loadFixture("edge-cases", "script-with-html.html");
      const insertionPoint = findInsertionPoint(html);

      // Check we're not inside a script tag
      const before = html.slice(0, insertionPoint);
      const lastScriptOpen = before.lastIndexOf("<script");
      const lastScriptClose = before.lastIndexOf("</script>");

      // If we found a script open, its close should come after it
      if (lastScriptOpen !== -1) {
        expect(lastScriptClose).toBeGreaterThan(lastScriptOpen);
      }
    });
  });

  describe("Style with HTML Content", () => {
    it("finds real </article> not one inside style", () => {
      const html = loadFixture("edge-cases", "style-with-html.html");
      const widget = createTestWidget();
      const loader = createTestLoader();

      const result = injectWidget(html, widget, loader);

      // Widget should be injected
      expect(result).toContain('id="moss-comments"');

      // CSS should be preserved
      expect(result).toContain("article::after");
    });
  });

  describe("Uppercase Tags", () => {
    it("handles uppercase HTML tags", () => {
      const html = loadFixture("edge-cases", "uppercase-tags.html");

      // Note: Our current implementation uses case-sensitive search
      // Uppercase </ARTICLE> won't be found by lastIndexOf("</article>")
      // It will fall back to </MAIN> or </BODY>
      const insertionPoint = findInsertionPoint(html);

      // Should find either </MAIN> or </BODY> or </ARTICLE>
      const textAtPoint = html.slice(insertionPoint, insertionPoint + 10).toUpperCase();
      expect(
        textAtPoint.startsWith("</ARTICLE") ||
        textAtPoint.startsWith("</MAIN") ||
        textAtPoint.startsWith("</BODY")
      ).toBe(true);
    });
  });

  describe("No Doctype", () => {
    it("handles pages without doctype", () => {
      const html = loadFixture("edge-cases", "no-doctype.html");
      const widget = createTestWidget();
      const loader = createTestLoader();

      const result = injectWidget(html, widget, loader);

      expect(result).toContain('id="moss-comments"');
      // Should not have added a doctype
      expect(result.startsWith("<html")).toBe(true);
    });
  });

  describe("Empty Body", () => {
    it("handles empty body tag", () => {
      const html = loadFixture("edge-cases", "empty-body.html");
      const insertionPoint = findInsertionPoint(html);

      // Should find </body> as fallback
      const textAtPoint = html.slice(insertionPoint, insertionPoint + 7);
      expect(textAtPoint).toBe("</body>");
    });
  });
});

describe("Performance", () => {
  it("handles large HTML files efficiently", () => {
    // Generate a large HTML file (simulating a long blog post)
    const largeContent = Array(1000)
      .fill("<p>This is a paragraph of content for testing performance.</p>")
      .join("\n");

    const html = `<!DOCTYPE html>
<html>
<head><title>Large Post</title></head>
<body>
<main>
<article>
<h1>Large Post</h1>
${largeContent}
</article>
</main>
</body>
</html>`;

    const widget = createTestWidget(10);
    const loader = createTestLoader();

    const startTime = performance.now();
    const result = injectWidget(html, widget, loader);
    const endTime = performance.now();

    // Should complete in under 100ms even for large files
    expect(endTime - startTime).toBeLessThan(100);

    // Widget should be correctly injected
    expect(result).toContain('id="moss-comments"');
  });
});
