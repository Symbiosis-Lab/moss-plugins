/**
 * Git command helpers for the GitHub Pages Publisher Plugin
 *
 * Executes git commands via moss-api's executeBinary.
 */
import { executeBinary } from "@symbiosis-lab/moss-api";
import { log } from "./utils";
/**
 * Run a git command and return the output
 */
async function runGit(args) {
    await log("log", `   git ${args.join(" ")}`);
    const result = await executeBinary({
        binaryPath: "git",
        args,
        timeoutMs: 60000,
    });
    if (!result.success) {
        const error = result.stderr || `Git command failed with exit code ${result.exitCode}`;
        throw new Error(error);
    }
    return result.stdout.trim();
}
/**
 * Check if a path exists using git status (works without direct filesystem access)
 */
export async function checkPathExists(relativePath) {
    try {
        // Try to get status of the path - if it doesn't exist, git will error
        await runGit(["ls-files", "--error-unmatch", relativePath]);
        return true;
    }
    catch {
        // Path not tracked, check if it exists on disk via a different approach
        // For .git directory, we can check by running a git command that requires it
        if (relativePath === ".git") {
            try {
                await runGit(["rev-parse", "--git-dir"]);
                return true;
            }
            catch {
                return false;
            }
        }
        return false;
    }
}
/**
 * Get the origin remote URL
 */
export async function getRemoteUrl() {
    return runGit(["remote", "get-url", "origin"]);
}
/**
 * Detect the default branch (main or master)
 */
export async function detectBranch() {
    try {
        // Try to get current branch first
        const branch = await runGit(["branch", "--show-current"]);
        if (branch) {
            return branch;
        }
    }
    catch {
        // Ignore - will try fallbacks
    }
    // Fallback: check if main exists
    try {
        await runGit(["rev-parse", "--verify", "main"]);
        return "main";
    }
    catch {
        // Ignore - will try master
    }
    // Fallback: check if master exists
    try {
        await runGit(["rev-parse", "--verify", "master"]);
        return "master";
    }
    catch {
        // Default to main
        return "main";
    }
}
/**
 * Check if directory is a git repository
 */
export async function isGitRepository() {
    try {
        await runGit(["rev-parse", "--git-dir"]);
        return true;
    }
    catch {
        return false;
    }
}
/**
 * Check if remote exists and get its URL
 */
export async function hasGitRemote() {
    try {
        await getRemoteUrl();
        return true;
    }
    catch {
        return false;
    }
}
/**
 * Stage files for commit
 */
export async function stageFiles(files) {
    await runGit(["add", ...files]);
}
/**
 * Create a commit with a message
 */
export async function commit(message) {
    await runGit(["commit", "-m", message]);
    return runGit(["rev-parse", "HEAD"]);
}
/**
 * Push to remote
 */
export async function push() {
    await runGit(["push"]);
}
/**
 * Stage, commit, and push workflow files
 */
export async function commitAndPushWorkflow() {
    await log("log", "   Staging workflow and gitignore...");
    await stageFiles([".github/workflows/moss-deploy.yml", ".gitignore"]);
    await log("log", "   Creating commit...");
    const sha = await commit("Add GitHub Pages deployment workflow\n\nGenerated by Moss");
    await log("log", "   Pushing to remote...");
    await push();
    return sha;
}
/**
 * Extract GitHub owner and repo from remote URL
 */
export function parseGitHubUrl(remoteUrl) {
    // Parse HTTPS URLs: https://github.com/user/repo.git
    const httpsMatch = remoteUrl.match(/^https:\/\/github\.com\/([^/]+)\/([^/.]+)(\.git)?$/);
    if (httpsMatch) {
        return { owner: httpsMatch[1], repo: httpsMatch[2] };
    }
    // Parse SSH URLs: git@github.com:user/repo.git
    const sshMatch = remoteUrl.match(/^git@github\.com:([^/]+)\/([^/.]+)(\.git)?$/);
    if (sshMatch) {
        return { owner: sshMatch[1], repo: sshMatch[2] };
    }
    return null;
}
/**
 * Extract GitHub Pages URL from remote URL
 */
export function extractGitHubPagesUrl(remoteUrl) {
    const parsed = parseGitHubUrl(remoteUrl);
    if (!parsed) {
        throw new Error("Could not parse GitHub URL from remote");
    }
    return `https://${parsed.owner}.github.io/${parsed.repo}`;
}
