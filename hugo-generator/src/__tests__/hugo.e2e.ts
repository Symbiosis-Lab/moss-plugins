/**
 * E2E tests for Hugo Generator Plugin
 *
 * These tests require Hugo to be installed on the system.
 * They create real Hugo sites and verify the build output.
 *
 * Run with: npm run test:e2e
 * Skip in CI without Hugo: tests will throw descriptive error
 */

import { describe, it, expect, beforeAll, afterAll, beforeEach } from "vitest";
import { execSync } from "child_process";
import * as fs from "fs/promises";
import * as path from "path";
import * as os from "os";

describe("Hugo Generator E2E", () => {
  let testDir: string;
  let hugoAvailable = false;

  beforeAll(async () => {
    // Check if Hugo is installed
    try {
      const version = execSync("hugo version", { encoding: "utf-8" });
      console.log(`Hugo available: ${version.trim()}`);
      hugoAvailable = true;
    } catch {
      console.warn(
        "Hugo not installed - E2E tests will be skipped. " +
          "Install Hugo to run these tests: https://gohugo.io/installation/"
      );
    }

    if (!hugoAvailable) return;

    // Create test directory
    testDir = path.join(os.tmpdir(), `hugo-generator-e2e-${Date.now()}`);

    // Create a new Hugo site
    execSync(`hugo new site "${testDir}"`, { stdio: "pipe" });

    // Add minimal content
    const contentDir = path.join(testDir, "content");
    await fs.mkdir(contentDir, { recursive: true });
    await fs.writeFile(
      path.join(contentDir, "_index.md"),
      `---
title: "Test Site"
date: 2024-01-01
---

# Hello from Hugo

This is a test site generated by the Hugo Generator plugin.
`
    );

    // Add a posts section
    const postsDir = path.join(contentDir, "posts");
    await fs.mkdir(postsDir, { recursive: true });
    await fs.writeFile(
      path.join(postsDir, "first-post.md"),
      `---
title: "First Post"
date: 2024-01-02
tags: ["test", "hugo"]
---

# First Post

This is the first post content.
`
    );
  });

  afterAll(async () => {
    if (testDir) {
      await fs.rm(testDir, { recursive: true, force: true }).catch(() => {
        // Ignore cleanup errors
      });
    }
  });

  beforeEach(() => {
    if (!hugoAvailable) {
      throw new Error(
        "Hugo not installed - skipping E2E test. " +
          "Install Hugo to run: https://gohugo.io/installation/"
      );
    }
  });

  describe("Hugo CLI Integration", () => {
    it("builds Hugo site to output directory", async () => {
      const outputDir = path.join(testDir, ".moss", "site");

      // Clean output directory if exists
      await fs.rm(outputDir, { recursive: true, force: true }).catch(() => {});

      // Run Hugo build
      execSync(
        `hugo --source "${testDir}" --destination "${outputDir}" --quiet`,
        { stdio: "pipe" }
      );

      // Verify index.html exists
      const indexPath = path.join(outputDir, "index.html");
      const exists = await fs
        .access(indexPath)
        .then(() => true)
        .catch(() => false);
      expect(exists).toBe(true);

      // Verify content is present
      const html = await fs.readFile(indexPath, "utf-8");
      expect(html).toContain("Test Site");
    });

    it("creates collection index for posts directory", async () => {
      const outputDir = path.join(testDir, ".moss", "site-collections");

      await fs.rm(outputDir, { recursive: true, force: true }).catch(() => {});

      execSync(
        `hugo --source "${testDir}" --destination "${outputDir}" --quiet`,
        { stdio: "pipe" }
      );

      // Hugo creates posts/index.html for the section
      const postsIndexPath = path.join(outputDir, "posts", "index.html");
      const exists = await fs
        .access(postsIndexPath)
        .then(() => true)
        .catch(() => false);
      expect(exists).toBe(true);
    });

    it("creates individual post HTML files", async () => {
      const outputDir = path.join(testDir, ".moss", "site-posts");

      await fs.rm(outputDir, { recursive: true, force: true }).catch(() => {});

      execSync(
        `hugo --source "${testDir}" --destination "${outputDir}" --quiet`,
        { stdio: "pipe" }
      );

      // Hugo creates posts/first-post/index.html
      const postPath = path.join(outputDir, "posts", "first-post", "index.html");
      const exists = await fs
        .access(postPath)
        .then(() => true)
        .catch(() => false);
      expect(exists).toBe(true);

      const html = await fs.readFile(postPath, "utf-8");
      expect(html).toContain("First Post");
    });

    it("applies --minify flag to reduce output size", async () => {
      const outputDirNormal = path.join(testDir, ".moss", "site-normal");
      const outputDirMinify = path.join(testDir, ".moss", "site-minify");

      await fs
        .rm(outputDirNormal, { recursive: true, force: true })
        .catch(() => {});
      await fs
        .rm(outputDirMinify, { recursive: true, force: true })
        .catch(() => {});

      // Build without minify
      execSync(
        `hugo --source "${testDir}" --destination "${outputDirNormal}" --quiet`,
        { stdio: "pipe" }
      );

      // Build with minify
      execSync(
        `hugo --source "${testDir}" --destination "${outputDirMinify}" --quiet --minify`,
        { stdio: "pipe" }
      );

      const normalHtml = await fs.readFile(
        path.join(outputDirNormal, "index.html"),
        "utf-8"
      );
      const minifyHtml = await fs.readFile(
        path.join(outputDirMinify, "index.html"),
        "utf-8"
      );

      // Minified should be smaller or equal (Hugo's default themes may already be minimal)
      expect(minifyHtml.length).toBeLessThanOrEqual(normalHtml.length);
    });

    it("handles missing config.toml gracefully", async () => {
      // Create a bare directory without hugo.toml/config.toml
      const bareDir = path.join(os.tmpdir(), `hugo-bare-${Date.now()}`);
      await fs.mkdir(bareDir, { recursive: true });

      const outputDir = path.join(bareDir, ".moss", "site");

      try {
        // Hugo should still work (uses defaults)
        execSync(
          `hugo --source "${bareDir}" --destination "${outputDir}" --quiet`,
          { stdio: "pipe" }
        );
        // If it succeeds, that's fine - Hugo can work without config
      } catch (error) {
        // Hugo may fail or warn, but shouldn't crash
        expect(error).toBeDefined();
      } finally {
        await fs.rm(bareDir, { recursive: true, force: true }).catch(() => {});
      }
    });
  });

  describe("Error Handling", () => {
    it("fails with clear error for invalid Hugo path", async () => {
      let errorThrown = false;
      let errorMessage = "";

      try {
        execSync(
          `/nonexistent/hugo --source "${testDir}" --destination "/tmp/out" --quiet`,
          { stdio: "pipe" }
        );
      } catch (error) {
        errorThrown = true;
        errorMessage = error instanceof Error ? error.message : String(error);
      }

      expect(errorThrown).toBe(true);
      expect(errorMessage).toBeTruthy();
    });

    it("fails for invalid source directory", async () => {
      let errorThrown = false;

      try {
        execSync(
          `hugo --source "/nonexistent/path" --destination "/tmp/out" --quiet`,
          { stdio: "pipe" }
        );
      } catch {
        errorThrown = true;
      }

      expect(errorThrown).toBe(true);
    });
  });
});
