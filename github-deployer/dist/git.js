/**
 * Git command helpers for the GitHub Pages Publisher Plugin
 *
 * Executes git commands via Tauri's execute_binary command.
 */
import { getTauriCore, log } from "./utils";
/**
 * Run a git command and return the output
 */
async function runGit(args, cwd) {
    await log("log", `   git ${args.join(" ")}`);
    const result = await getTauriCore().invoke("execute_binary", {
        binaryPath: "git",
        args,
        workingDir: cwd,
        timeoutMs: 60000,
    });
    if (!result.success) {
        const error = result.stderr || `Git command failed with exit code ${result.exit_code}`;
        throw new Error(error);
    }
    return result.stdout.trim();
}
/**
 * Check if a path exists using git status (works without direct filesystem access)
 */
export async function checkPathExists(projectPath, relativePath) {
    try {
        // Try to get status of the path - if it doesn't exist, git will error
        await runGit(["ls-files", "--error-unmatch", relativePath], projectPath);
        return true;
    }
    catch {
        // Path not tracked, check if it exists on disk via a different approach
        // For .git directory, we can check by running a git command that requires it
        if (relativePath === ".git") {
            try {
                await runGit(["rev-parse", "--git-dir"], projectPath);
                return true;
            }
            catch {
                return false;
            }
        }
        return false;
    }
}
/**
 * Get the origin remote URL
 */
export async function getRemoteUrl(projectPath) {
    return runGit(["remote", "get-url", "origin"], projectPath);
}
/**
 * Detect the default branch (main or master)
 */
export async function detectBranch(projectPath) {
    try {
        // Try to get current branch first
        const branch = await runGit(["branch", "--show-current"], projectPath);
        if (branch) {
            return branch;
        }
    }
    catch {
        // Ignore - will try fallbacks
    }
    // Fallback: check if main exists
    try {
        await runGit(["rev-parse", "--verify", "main"], projectPath);
        return "main";
    }
    catch {
        // Ignore - will try master
    }
    // Fallback: check if master exists
    try {
        await runGit(["rev-parse", "--verify", "master"], projectPath);
        return "master";
    }
    catch {
        // Default to main
        return "main";
    }
}
/**
 * Check if directory is a git repository
 */
export async function isGitRepository(projectPath) {
    try {
        await runGit(["rev-parse", "--git-dir"], projectPath);
        return true;
    }
    catch {
        return false;
    }
}
/**
 * Check if remote exists and get its URL
 */
export async function hasGitRemote(projectPath) {
    try {
        await getRemoteUrl(projectPath);
        return true;
    }
    catch {
        return false;
    }
}
/**
 * Stage files for commit
 */
export async function stageFiles(projectPath, files) {
    await runGit(["add", ...files], projectPath);
}
/**
 * Create a commit with a message
 */
export async function commit(projectPath, message) {
    await runGit(["commit", "-m", message], projectPath);
    return runGit(["rev-parse", "HEAD"], projectPath);
}
/**
 * Push to remote
 */
export async function push(projectPath) {
    await runGit(["push"], projectPath);
}
/**
 * Stage, commit, and push workflow files
 */
export async function commitAndPushWorkflow(projectPath) {
    await log("log", "   Staging workflow and gitignore...");
    await stageFiles(projectPath, [".github/workflows/moss-deploy.yml", ".gitignore"]);
    await log("log", "   Creating commit...");
    const sha = await commit(projectPath, "Add GitHub Pages deployment workflow\n\nGenerated by Moss");
    await log("log", "   Pushing to remote...");
    await push(projectPath);
    return sha;
}
/**
 * Extract GitHub owner and repo from remote URL
 */
export function parseGitHubUrl(remoteUrl) {
    // Parse HTTPS URLs: https://github.com/user/repo.git
    const httpsMatch = remoteUrl.match(/^https:\/\/github\.com\/([^/]+)\/([^/.]+)(\.git)?$/);
    if (httpsMatch) {
        return { owner: httpsMatch[1], repo: httpsMatch[2] };
    }
    // Parse SSH URLs: git@github.com:user/repo.git
    const sshMatch = remoteUrl.match(/^git@github\.com:([^/]+)\/([^/.]+)(\.git)?$/);
    if (sshMatch) {
        return { owner: sshMatch[1], repo: sshMatch[2] };
    }
    return null;
}
/**
 * Extract GitHub Pages URL from remote URL
 */
export function extractGitHubPagesUrl(remoteUrl) {
    const parsed = parseGitHubUrl(remoteUrl);
    if (!parsed) {
        throw new Error("Could not parse GitHub URL from remote");
    }
    return `https://${parsed.owner}.github.io/${parsed.repo}`;
}
//# sourceMappingURL=git.js.map