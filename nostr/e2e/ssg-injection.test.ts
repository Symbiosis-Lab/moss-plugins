/**
 * Unit Tests for SSG-aware Widget Injection
 *
 * These tests verify that the Nostr comment widget correctly injects
 * into HTML generated by different Static Site Generators (SSGs).
 *
 * Test categories:
 * 1. SSG Detection - Verify correct SSG identification from HTML
 * 2. Insertion Point - Verify widget is inserted at the correct location
 * 3. Edge Cases - Verify handling of unusual HTML structures
 * 4. XSS Prevention - Verify malicious content is escaped
 *
 * Note: These are unit tests using inline HTML strings, not e2e tests.
 * For full pipeline e2e tests, see moss-pipeline.test.ts
 */

import { describe, it, expect } from "vitest";
import {
  findInsertionPoint,
  injectWidget,
  detectSSG,
  type SSGType,
} from "../src/widget/inject";

/**
 * Create test widget HTML
 */
function createTestWidget(interactionCount: number = 1): string {
  return `<section id="moss-comments" class="social-interactions">
  <script type="application/json" id="moss-comments-data">
    {"interactions": ${JSON.stringify(Array(interactionCount).fill({ id: "test", content: "Test comment" }))}}
  </script>
  <noscript>
    <div class="interactions-static">
      <h3>Comments (${interactionCount})</h3>
      <p>Test comment</p>
    </div>
  </noscript>
</section>`;
}

/**
 * Create test loader script
 */
function createTestLoader(): string {
  return `
<script>
(function() {
  if (!document.getElementById('moss-comments')) return;
  var s = document.createElement('script');
  s.src = '/js/moss-comments.js';
  s.async = true;
  document.body.appendChild(s);
})();
</script>`;
}

// Sample HTML for each SSG
const SSG_HTML = {
  hugo: `<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="generator" content="Hugo 0.123.0">
    <title>Test Post - Hugo Site</title>
</head>
<body>
    <header><nav><a href="/">Home</a></nav></header>
    <main>
        <article class="post">
            <h1>Test Post</h1>
            <p>Content here.</p>
        </article>
    </main>
    <footer><p>Footer</p></footer>
</body>
</html>`,

  hexo: `<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <meta name="generator" content="Hexo 6.3.0">
    <title>Test Post | Hexo Blog</title>
</head>
<body>
    <div id="container">
        <article id="post-test" class="article">
            <h1>Test Post</h1>
            <div class="article-entry">Content here.</div>
        </article>
    </div>
</body>
</html>`,

  astro: `<!DOCTYPE html>
<html lang="en" data-astro-cid-sckkx6r4>
<head><meta charset="UTF-8"><title>Test</title></head>
<body data-astro-cid-sckkx6r4>
    <main data-astro-cid-sckkx6r4>
        <article data-astro-cid-j7pv25f6>
            <h1>Test Post</h1>
            <p>Content here.</p>
        </article>
    </main>
</body>
</html>`,

  jekyll: `<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="generator" content="Jekyll v4.3.2">
    <title>Test Post</title>
</head>
<body>
    <main>
        <article class="post h-entry">
            <h1>Test Post</h1>
            <div class="post-content e-content">Content here.</div>
        </article>
    </main>
</body>
</html>`,

  zola: `<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="generator" content="Zola v0.18.0">
    <title>Test Post</title>
</head>
<body>
    <main>
        <article class="post">
            <h1>Test Post</h1>
            <section class="body">Content here.</section>
        </article>
    </main>
</body>
</html>`,

  eleventy: `<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="generator" content="Eleventy v2.0.1">
    <title>Test Post</title>
</head>
<body>
    <main>
        <article>
            <h1>Test Post</h1>
            <div class="content">Content here.</div>
        </article>
    </main>
</body>
</html>`,
};

// Edge case HTML samples
const EDGE_CASE_HTML = {
  noArticle: `<!DOCTYPE html>
<html><head><title>About</title></head>
<body>
    <main>
        <div class="page-content">
            <h1>About Us</h1>
            <p>No article tag here.</p>
        </div>
    </main>
</body>
</html>`,

  nestedArticles: `<!DOCTYPE html>
<html><head><title>Nested</title></head>
<body>
    <main>
        <article class="main-post">
            <h1>Main Article</h1>
            <aside>
                <article class="related">Related article</article>
            </aside>
            <p>More content.</p>
        </article>
    </main>
</body>
</html>`,

  minimal: `<!DOCTYPE html>
<html><head><title>Minimal</title></head>
<body><article><h1>Minimal</h1><p>Content.</p></article></body>
</html>`,

  uppercaseTags: `<!DOCTYPE html>
<HTML>
<HEAD><TITLE>Uppercase</TITLE></HEAD>
<BODY>
    <MAIN>
        <ARTICLE>
            <H1>Uppercase Tags</H1>
            <P>Legacy HTML with uppercase tags.</P>
        </ARTICLE>
    </MAIN>
</BODY>
</HTML>`,

  noDoctype: `<html>
<head><title>No Doctype</title></head>
<body><article><h1>Post</h1><p>No doctype.</p></article></body>
</html>`,

  emptyBody: `<!DOCTYPE html>
<html><head><title>Empty</title></head>
<body>
</body>
</html>`,

  scriptWithHtml: `<!DOCTYPE html>
<html><head><title>Script</title>
<script>
const html = '</article>';
document.write('</article>');
</script>
</head>
<body>
    <main>
        <article>
            <h1>Post</h1>
            <p>Has scripts with HTML strings.</p>
        </article>
    </main>
</body>
</html>`,

  commentsWithHtml: `<!DOCTYPE html>
<html><head><title>Comments</title></head>
<body>
    <!-- </article> in comment -->
    <main>
        <article>
            <h1>Post</h1>
            <!-- Another </article> -->
            <p>Content.</p>
        </article>
    </main>
</body>
</html>`,

  unicode: `<!DOCTYPE html>
<html lang="zh">
<head><meta charset="UTF-8"><title>‰∏≠ÊñáÊµãËØï</title></head>
<body>
    <main>
        <article>
            <h1>‰∏≠ÊñáÂÜÖÂÆπÊµãËØï</h1>
            <p>‰Ω†Â•Ω‰∏ñÁïå üåç „Åì„Çì„Å´„Å°„ÅØ ÏïàÎÖïÌïòÏÑ∏Ïöî</p>
        </article>
    </main>
</body>
</html>`,

  multipleMain: `<!DOCTYPE html>
<html><head><title>Multiple Main</title></head>
<body>
    <header><main class="header-main"><nav>Nav</nav></main></header>
    <main class="content-main">
        <article><h1>Post</h1><p>Content.</p></article>
    </main>
    <footer><main class="footer-main"><p>Footer</p></main></footer>
</body>
</html>`,
};

describe("SSG Detection", () => {
  it("detects Hugo from generator meta tag", () => {
    expect(detectSSG(SSG_HTML.hugo)).toBe("hugo");
  });

  it("detects Hexo from generator meta tag", () => {
    expect(detectSSG(SSG_HTML.hexo)).toBe("hexo");
  });

  it("detects Astro from data-astro attributes", () => {
    expect(detectSSG(SSG_HTML.astro)).toBe("astro");
  });

  it("detects Jekyll from generator meta tag", () => {
    expect(detectSSG(SSG_HTML.jekyll)).toBe("jekyll");
  });

  it("detects Zola from generator meta tag", () => {
    expect(detectSSG(SSG_HTML.zola)).toBe("zola");
  });

  it("detects Eleventy from generator meta tag", () => {
    expect(detectSSG(SSG_HTML.eleventy)).toBe("11ty");
  });

  it("returns unknown for pages without SSG markers", () => {
    expect(detectSSG(EDGE_CASE_HTML.minimal)).toBe("unknown");
  });
});

describe("Insertion Point Finding", () => {
  describe("SSG HTML", () => {
    const ssgTypes: (keyof typeof SSG_HTML)[] = [
      "hugo",
      "hexo",
      "astro",
      "jekyll",
      "zola",
      "eleventy",
    ];

    ssgTypes.forEach((ssg) => {
      it(`finds </article> tag in ${ssg} structure`, () => {
        const html = SSG_HTML[ssg];
        const insertionPoint = findInsertionPoint(html);
        expect(html.slice(insertionPoint, insertionPoint + 10)).toBe("</article>");
      });
    });
  });

  describe("Edge Cases", () => {
    it("falls back to </main> when no article tag exists", () => {
      const insertionPoint = findInsertionPoint(EDGE_CASE_HTML.noArticle);
      expect(
        EDGE_CASE_HTML.noArticle.slice(insertionPoint, insertionPoint + 7)
      ).toBe("</main>");
    });

    it("finds the last </article> tag with nested articles", () => {
      const html = EDGE_CASE_HTML.nestedArticles;
      const insertionPoint = findInsertionPoint(html);
      const lastArticleIndex = html.lastIndexOf("</article>");
      expect(insertionPoint).toBe(lastArticleIndex);
    });

    it("handles uppercase HTML tags", () => {
      const html = EDGE_CASE_HTML.uppercaseTags;
      const insertionPoint = findInsertionPoint(html);
      // Should find </ARTICLE>
      expect(html.slice(insertionPoint, insertionPoint + 10)).toBe("</ARTICLE>");
    });

    it("falls back to </body> for empty body", () => {
      const insertionPoint = findInsertionPoint(EDGE_CASE_HTML.emptyBody);
      expect(
        EDGE_CASE_HTML.emptyBody.slice(insertionPoint, insertionPoint + 7)
      ).toBe("</body>");
    });

    it("finds real </article> not one inside script", () => {
      const html = EDGE_CASE_HTML.scriptWithHtml;
      const insertionPoint = findInsertionPoint(html);
      // The last </article> in the HTML is the real one, not the one in script
      const before = html.slice(0, insertionPoint);
      const lastScriptOpen = before.lastIndexOf("<script");
      const lastScriptClose = before.lastIndexOf("</script>");
      if (lastScriptOpen !== -1) {
        expect(lastScriptClose).toBeGreaterThan(lastScriptOpen);
      }
    });

    it("handles pages without doctype", () => {
      const html = EDGE_CASE_HTML.noDoctype;
      const insertionPoint = findInsertionPoint(html);
      expect(html.slice(insertionPoint, insertionPoint + 10)).toBe("</article>");
    });
  });
});

describe("Widget Injection", () => {
  const ssgTypes: (keyof typeof SSG_HTML)[] = [
    "hugo",
    "hexo",
    "astro",
    "jekyll",
    "zola",
    "eleventy",
  ];

  ssgTypes.forEach((ssg) => {
    describe(ssg.toUpperCase(), () => {
      it("injects widget with correct structure", () => {
        const html = SSG_HTML[ssg];
        const widget = createTestWidget(3);
        const loader = createTestLoader();

        const result = injectWidget(html, widget, loader);

        expect(result).toContain('id="moss-comments"');
        expect(result).toContain('id="moss-comments-data"');
        expect(result).toContain("<noscript>");
        expect(result).toContain("Comments (3)");
        expect(result).toContain("moss-comments.js");
        expect(result).toContain("Test Post");
      });

      it("adds data-preserve-scroll attribute", () => {
        const html = SSG_HTML[ssg];
        const widget = createTestWidget();
        const loader = createTestLoader();

        const result = injectWidget(html, widget, loader);

        expect(result).toContain('data-preserve-scroll="true"');
      });

      it("places loader script before </body>", () => {
        const html = SSG_HTML[ssg];
        const widget = createTestWidget();
        const loader = createTestLoader();

        const result = injectWidget(html, widget, loader);

        const loaderIndex = result.indexOf("moss-comments.js");
        const bodyEndIndex = result.lastIndexOf("</body>");

        expect(loaderIndex).toBeLessThan(bodyEndIndex);
        expect(loaderIndex).toBeGreaterThan(0);
      });
    });
  });
});

describe("Edge Case Widget Injection", () => {
  it("handles uppercase tags", () => {
    const html = EDGE_CASE_HTML.uppercaseTags;
    const widget = createTestWidget();
    const loader = createTestLoader();

    const result = injectWidget(html, widget, loader);

    expect(result).toContain('id="moss-comments"');
    // Should preserve uppercase structure
    expect(result).toContain("</BODY>");
  });

  it("handles Unicode content correctly", () => {
    const html = EDGE_CASE_HTML.unicode;
    const widget = createTestWidget();
    const loader = createTestLoader();

    const result = injectWidget(html, widget, loader);

    // Original Unicode content should be preserved
    expect(result).toContain("‰∏≠ÊñáÂÜÖÂÆπÊµãËØï");
    expect(result).toContain("„Åì„Çì„Å´„Å°„ÅØ");
    expect(result).toContain("üåç");
    expect(result).toContain('id="moss-comments"');
  });

  it("handles multiple main tags", () => {
    const html = EDGE_CASE_HTML.multipleMain;
    const widget = createTestWidget();
    const loader = createTestLoader();

    const result = injectWidget(html, widget, loader);

    // Should find </article>, not any of the </main> tags
    expect(result).toContain('id="moss-comments"');
  });

  it("injects into minimal HTML", () => {
    const html = EDGE_CASE_HTML.minimal;
    const widget = createTestWidget();
    const loader = createTestLoader();

    const result = injectWidget(html, widget, loader);

    expect(result).toContain('id="moss-comments"');
    expect(result).toContain("</body>");
  });
});

describe("XSS Prevention", () => {
  it("JSON data escapes script tags", () => {
    // Create widget with malicious content
    const maliciousInteraction = {
      id: "xss-test",
      content: '<script>alert("xss")</script>',
    };

    const widgetHtml = `<section id="moss-comments">
  <script type="application/json" id="moss-comments-data">
    ${JSON.stringify({ interactions: [maliciousInteraction] })}
  </script>
  <noscript>
    <div class="interactions-static">
      <p>&lt;script&gt;alert("xss")&lt;/script&gt;</p>
    </div>
  </noscript>
</section>`;

    const loader = createTestLoader();
    const result = injectWidget(EDGE_CASE_HTML.minimal, widgetHtml, loader);

    // The noscript fallback should have escaped HTML
    expect(result).toContain("&lt;script&gt;");

    // The raw script tag should not appear in the noscript section
    const noscriptSection =
      result.match(/<noscript>[\s\S]*?<\/noscript>/)?.[0] ?? "";
    expect(noscriptSection).not.toContain('<script>alert');
  });
});

describe("Performance", () => {
  it("handles large HTML files efficiently", () => {
    const largeContent = Array(1000)
      .fill("<p>This is a paragraph of content for testing performance.</p>")
      .join("\n");

    const html = `<!DOCTYPE html>
<html><head><title>Large</title></head>
<body>
<main>
<article>
<h1>Large Post</h1>
${largeContent}
</article>
</main>
</body>
</html>`;

    const widget = createTestWidget(10);
    const loader = createTestLoader();

    const startTime = performance.now();
    const result = injectWidget(html, widget, loader);
    const endTime = performance.now();

    // Should complete in under 100ms
    expect(endTime - startTime).toBeLessThan(100);
    expect(result).toContain('id="moss-comments"');
  });
});
